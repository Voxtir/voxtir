generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum TranscriptionType {
    AUTOMATIC
    MANUAL
}

model Document {
    id                               String                            @id @default(uuid())
    title                            String
    createdAt                        DateTime                          @default(now())
    updatedAt                        DateTime                          @updatedAt
    project                          Project                           @relation(fields: [projectId], references: [id])
    projectId                        String // relation scalar field (used in the `@relation` attribute above)  
    // TipTap document data
    data                             Bytes?
    // Audio file
    audioFileURL                     String?
    // Transcription data
    language                         String?
    speakerCount                     Int?
    dialect                          String?
    transcriptionType                TranscriptionType
    // Automatic transcription data
    transcriptionStatus              TranscriptionProcessStatus?
    doSpeakerDiarization             Boolean?
    mergedTranscriptionFileURL       String?
    speakerDiarizationFileURL        String?
    speechToTextFileURL              String?
    transcriptionStartedAt           DateTime?
    transcriptionFinishedAt          DateTime?
    // Since TipTap/Prosemirror enforces a very strict schema, we need to store which version of the transcript processing logic 
    // was used to generate the transcript to be able to determine how to parse it when loading it into the editor in the frontend
    transcriptProcessingLogicVersion TranscriptProcessingLogicVersion?

    // Other
    isTrashed Boolean @default(false)

    @@index([projectId])
}

enum TranscriptProcessingLogicVersion {
    V1
}

enum TranscriptionProcessStatus {
    CREATED
    QUEUED
    PROCESSING
    FAILED
    DONE
}

model User {
    id                            String              @id
    auth0ManagementApiUserDetails Json?
    UsersOnProjects               UserOnProject[]
    PinnedProjects                PinnedProjects[]
    ProjectInvitation             ProjectInvitation[]
}

model Project {
    id                String              @id @default(uuid())
    name              String
    description       String?
    createdAt         DateTime            @default(now())
    updatedAt         DateTime            @updatedAt
    UsersOnProjects   UserOnProject[]
    Documents         Document[]
    ProjectInvitation ProjectInvitation[]
    PinnedProjects    PinnedProjects[]
}

model UserOnProject {
    id        String      @id @default(uuid())
    project   Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
    projectId String // relation scalar field (used in the `@relation` attribute above)
    user      User        @relation(fields: [userId], references: [id])
    userId    String // relation scalar field (used in the `@relation` attribute above)
    role      ProjectRole
    createdAt DateTime    @default(now())
    updatedAt DateTime    @updatedAt

    @@index([projectId, userId])
}

enum ProjectRole {
    ADMIN
    MEMBER
}

model ProjectInvitation {
    id        String      @id @default(uuid())
    project   Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
    projectId String // relation scalar field (used in the `@relation` attribute above)
    email     String
    role      ProjectRole
    token     String      @unique
    used      Boolean     @default(false)
    usedBy    User?       @relation(fields: [usedById], references: [id])
    usedById  String? // relation scalar field (used in the `@relation` attribute above)
    expiresAt DateTime
    createdAt DateTime    @default(now())
    updatedAt DateTime    @updatedAt

    @@index([projectId, email, token])
}

model PinnedProjects {
    id        String   @id @default(uuid())
    project   Project  @relation(fields: [projectId], references: [id])
    projectId String // relation scalar field (used in the `@relation` attribute above)
    user      User     @relation(fields: [userId], references: [id])
    userId    String // relation scalar field (used in the `@relation` attribute above)
    pinned    Boolean  @default(true)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([projectId, userId])
    @@index([projectId, userId])
}
